
1. Linear Data Structures

These store data sequentially.

Array / Dynamic Array (e.g., Python list, C++ vector)

Fixed or resizable collections.

Fast index-based access.


Linked List (Singly, Doubly, Circular)

Efficient insertions/deletions at arbitrary positions.

Useful for queues, stacks, or custom memory management.


Stack

LIFO (Last In, First Out) principle.

Useful in recursion, expression evaluation, undo functionality.


Queue

FIFO (First In, First Out) principle.

Variants:

Deque (Double-ended queue)

Priority Queue / Heap

Supports ordering by priority (min-heap/max-heap).




String / Character Array

Strings are often treated as arrays of characters.

Efficient manipulation and pattern matching require understanding underlying structures.




---

2. Hash-Based Structures

Allow near O(1) average-time lookup.

Hash Table / Hash Map / Dictionary

Key-value store.

Used in caching, indexing, counting frequencies, etc.


Hash Set

Unordered collection of unique items.

Efficient for membership checking.




---

3. Tree Structures

Hierarchical structures used for efficient searching, sorting, and hierarchical data representation.

Binary Tree

Each node has ≤ 2 children.


Binary Search Tree (BST)

Ordered tree, supports efficient search, insertion, deletion.


Balanced BSTs (AVL, Red-Black Tree, Splay Tree)

Maintain height balance for guaranteed O(log n) operations.


Segment Tree / Interval Tree / Fenwick Tree (Binary Indexed Tree)

Useful for range queries and updates.


Trie (Prefix Tree)

Efficient for storing and searching strings, autocomplete.


Heap / Priority Queue (Binary Heap, Fibonacci Heap)

Efficient min/max operations.




---

4. Graph Structures

Model relationships between entities.

Adjacency List

Efficient for sparse graphs.


Adjacency Matrix

Efficient for dense graphs, constant-time edge lookup.


Edge List

Special Graphs

Directed, Undirected, Weighted, Unweighted, Cyclic, Acyclic, DAGs.


Disjoint Set / Union-Find

Efficient connected-component detection, Kruskal’s MST.




---

5. Specialized / Advanced Structures

Circular Buffer / Ring Buffer

Efficient streaming data structure.


Bloom Filter

Probabilistic membership testing.


Skip List

Probabilistic alternative to balanced trees.


Suffix Tree / Suffix Array

Efficient substring search.


LRU Cache

Combines hash map + doubly-linked list.


Multiset / Multimap

Store multiple values per key (sorted or unordered).




---

6. Others / Variants

Bitset / Bit Vector

Efficient storage and operations on bits.


Matrix / 2D Array

Used in graphs, grids, image processing.


Deque

Combines stack and queue capabilities.




---

✅ Key Takeaways

Arrays, stacks, queues, hash maps, and trees are foundational.

Graphs, tries, heaps, and advanced trees appear frequently in algorithms and competitive programming.

Specialized structures like Bloom Filters or Suffix Trees are useful in high-performance or niche applications.



---

If you want, I can also make a visual “map” of data structures showing their relationships and typical use cases—super handy for study and interviews.

Do you want me to make that?